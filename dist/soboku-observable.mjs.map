{"version":3,"file":"soboku-observable.mjs","sources":["../src/observable.ts","../src/sequenceEqual.ts","../src/timer.ts"],"sourcesContent":["import { listener, reporter, Reporter, ReporterClass } from \"soboku\";\r\nimport { ISObservable } from \"../index.d\";\r\n\r\n\r\nexport abstract class SObservable<I, O, T extends Reporter<I>> implements ISObservable<I, O, T> {\r\n    public readonly input: T;\r\n    public readonly output = reporter<O>();\r\n    public readonly error = new ObservableErrorClass();\r\n    public readonly reset = reporter<true>();\r\n\r\n    constructor(input: T) {\r\n        this.input = input;\r\n        input.report(listener(this.onInput, this));\r\n        this.reset.report(listener(this.onReset, this));\r\n    }\r\n    \r\n    protected abstract onInput(val: I): void;\r\n    protected abstract onReset(): void;\r\n\r\n}\r\n\r\nexport  class ObservableErrorClass extends ReporterClass<Error> {\r\n\r\n    public next(err: Error) {\r\n        if (this.listenerCount() === 0) {\r\n            const unhandledError = new Error(`Unhandled observable error: ${err.name}: ${err.message}`);\r\n            unhandledError.name = \"UnhandledObservableErrorWarning\";\r\n            throw unhandledError;\r\n        }\r\n        return super.next(err);\r\n    }\r\n    \r\n}","import { reporter, ReporterClass, toStateHolder, Reporter, ISArray, IStateHolder } from \"soboku\";\r\nimport { ISObservable } from \"../index.d\";\r\nimport { SObservable } from \"./observable\";\r\n\r\n\r\nfunction isEqual(x: any, y: any): boolean {\r\n    return x === y;\r\n}\r\n\r\nclass SequenceEqualClass<T> extends SObservable<T, true, Reporter<T>> {\r\n    private readonly compare: (x: any, y: any) => boolean;\r\n    private readonly sequence: IStateHolder<T[]>;\r\n    private i = 0;\r\n\r\n    constructor(sequence: T[] | ISArray<T>, compare = isEqual) {\r\n        super(reporter<T>());\r\n        this.compare = compare;\r\n        this.sequence =  toStateHolder(sequence);\r\n    }\r\n\r\n    protected onInput(val: T): void {\r\n        const sequence = this.sequence.s();\r\n        if (this.compare(sequence[this.i], val) === false) {\r\n            this.i = 0;\r\n            return;\r\n        }\r\n        if (++this.i === sequence.length) {\r\n            this.i = 0;\r\n            this.output.next(true);\r\n        }\r\n    }\r\n\r\n    protected onReset() {\r\n        this.i = 0;\r\n    }\r\n    \r\n}\r\n\r\nexport function sequenceEqual<T>(sequence: T[] | ISArray<T>, compareFunc?: (x: T, y: T) => boolean): ISObservable<T, true, Reporter<T>> {\r\n    return new SequenceEqualClass(sequence, compareFunc);\r\n}\r\n","import { listener, state, ReporterClass, toStateHolder, Atom, Reporter, State, IStateHolder } from \"soboku\";\r\nimport { ISObservable } from \"../index.d\";\r\nimport { SObservable } from \"./observable\";\r\n\r\n\r\nabstract class TimerObservable extends SObservable<boolean, number, State<boolean>> {\r\n    protected readonly cb = () => this.output.next(Date.now());\r\n    protected readonly ms: IStateHolder<number>;\r\n    protected timer: NodeJS.Timer;\r\n    protected isRunning = false;\r\n\r\n    constructor(ms: Atom<number>) {\r\n        super(state(false));\r\n        const _ms = this.ms = toStateHolder(ms);\r\n        if (_ms instanceof ReporterClass)\r\n            _ms.report(listener(this.msChanged, this));\r\n    }\r\n\r\n    private msChanged(ms: number) {\r\n        if (this.isRunning) {\r\n            this.onInput(false);\r\n            this.onInput(true, ms);\r\n        }\r\n    }\r\n\r\n    protected onInput(trigger: boolean, ms?: number): void {\r\n        this.fire(trigger, ms || this.ms.s());\r\n        this.isRunning = trigger;\r\n    }\r\n\r\n    protected onReset() {\r\n        this.input.next(false);\r\n    }\r\n\r\n    protected abstract fire(trigger: boolean, ms: number): void;\r\n\r\n}\r\n\r\nclass IntervalObservable extends TimerObservable {\r\n\r\n    protected fire(trigger: boolean, ms: number) {\r\n        if (trigger === false) {\r\n            clearInterval(this.timer);\r\n        } else if (this.isRunning === false) {\r\n            this.timer = setInterval(this.cb, ms);\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nclass TimeoutObservable extends TimerObservable {\r\n\r\n    protected fire(trigger: boolean, ms: number) {\r\n        clearTimeout(this.timer);\r\n        if (trigger) {\r\n            this.timer = setTimeout(this.cb, ms);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nexport function interval(ms: Atom<number>): ISObservable<boolean, number, State<boolean>> {\r\n    return new IntervalObservable(ms);\r\n}\r\n\r\nexport function timeout(ms: Atom<number>): ISObservable<boolean, number, State<boolean>> {\r\n    return new TimeoutObservable(ms);\r\n}\r\n"],"names":[],"mappings":"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"}